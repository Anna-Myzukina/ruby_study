=begin
Правила доступа к методу
Хотя конечный пользователь вашей программы никогда не будет использовать методы, 
которые вы определили непосредственно в классе, все же полезно контролировать доступ к вашим методам. 
Представьте себе командную ситуацию, в которой несколько разработчиков используют экземпляры одного класса; 
полезно контролировать, какие методы можно использовать.

Простой способ понять разницу - представить, что наш класс - это самолет (на самом деле я пишу его на борту).

Публичные методы
В нашем классе Plane у нас есть несколько открытых методов экземпляра. 
Нам не нужно указывать, что метод будет общедоступным, потому что он используется по умолчанию.
=end
class Plane

  attr_reader :type, :fuel, :landed, :people, :personal_info_of_passengers, :burning_fuel

  def initialize(model)
      @model = model
      @fuel = 100
      @airborne = false
      @burning_fuel = false
  end

  def take_off
      puts "Firing up engines"
      puts "Fuel levels are #{fuel}."
      @airborne = true
      fire_up_engine
  end
  
  def fire_up_engine
      puts "firing up the engine"
      begin_gas_combustion
  end

  def begin_gas_combustion
      puts "combustin' the gas!"
      burning_fuel = true
  end

  def personal_info_of_passengers(people)
      people.map do |person|
          person.social_security_number
      end
  end

end 

=begin
Вау, подожди секунду. Хорошо, что мы можем видеть, с каким типом самолета мы работаем, 
уровень топлива и даже в воздухе или нет. 
Однако есть несколько вещей, которые мы определенно не хотим использовать за пределами нашего класса.

Об объекте легко думать как о чем-то, что выполняет за вас задачи, а его методы - 
это действия, выполняющие эти действия. 
Публичные методы похожи на API, где выполняются вызовы экземпляров объекта. 
С другой стороны, приватные методы - это задачи, которые вы не хотите использовать свободно. 
Например, метод begin_gas_combustion является компонентом метода fire_up_engine, но неясно, 
хотите ли вы использовать его в любом другом контексте. На самом деле, вероятно, 
было бы небезопасно использовать его в других контекстах. 
К счастью, Ruby позволяет использовать частные методы, чтобы обойти эту проблему.


Частные Методы
Закрытый метод не может быть вызван с явным получателем. 
Это означает, что если мы указываем begin_gas_combustion как частный метод, мы не сможем явно вызывать
begin_gas_combustion для экземпляров нашего класса Plane. 
Давайте перепишем немного нашего класса Plane:


=end
class Plane

...

  def fire_up_engine
      puts "firing up the engine"
      begin_gas_combustion
  end

  private
  
      def begin_gas_combustion
          "combustin' da gas!"
          burning_fuel = true
      end

end

=begin
Хорошо, кажется, это имеет больше смысла. Давайте проверим наши методы. Если вы попробуете, вы получите следующее:
=end
wills_plane = Plane.new(747)
wills_plane.begin_gas_combustion

#=> '<main>': private method 'begin_gas_combustion' called for #<Plane:0x00000002aeae50> (NoMethodError)`
=begin
Это имеет смысл, основываясь на нашем определении частных методов - теперь экземпляр будет явным получателем метода, 
который был вызван. Однако, когда мы попробуем следующее:

=end
wills_plane.fire_up_engine

#=> "firing up the engine"
#=> "combustin' da gas!"

=begin
Здесь, поскольку метод вызывается в открытом методе, 
существует неявный получатель - конкретный экземпляр объекта - и мы в порядке.
=end
#Private Setter (=) Methods

=begin
Частные методы с правилом «без явного получателя», однако, имеют проблемы с методами записи / установки. 
В этих методах вы не можете использовать неявный получатель, поскольку Ruby предполагает, 
что вы используете локальную переменную вместо метода без ключевого слова self. 
Следовательно, есть исключение - Ruby не применяет правило к методам установки, 
пока явный получатель сам.

Вы можете обойти частные методы с помощью «отправить»
Однако Руби дала нам возможность обойти наше правило. 
Вы всегда можете просто использовать метод send для отправки любого метода любому объекту.

Надеюсь, это прояснит ценность / использование частных методов, и увидимся в следующий раз.
=end
